nfsPVC:
  enabled: true
jupyterhub:
  auth:
    google:
      hostedDomain: ['berkeley.edu']
  scheduling:
    userScheduler:
      enabled: true
  proxy:
    https:
      letsencrypt:
        contactEmail: yuvipanda@berkeley.edu
    networkPolicy:
      enabled: true
  singleuser:
    defaultUrl: /tree
    networkPolicy:
      # In clusters with NetworkPolicy enabled, do not
      # allow outbound internet access that's not DNS, HTTP or HTTPS
      # We can override this on a case to case basesi where
      # required.
      enabled: true
      egress:
        - ports:
            - port: 53
              protocol: UDP
        - ports:
            - port: 80
              protocol: TCP
        - ports:
            - port: 443
              protocol: TCP
  hub:
    # Generated by chartpress
    image:
      name: gcr.io/ucb-datahub-2018/jupyterhub-hub
      tag: '0.1.0-2146694'
    networkPolicy:
      enabled: true
    extraEnv:
      OAUTH2_AUTHORIZE_URL: 'https://bcourses.berkeley.edu/login/oauth2/auth'
    extraConfig:
      010-canvas-auth: |
        import z2jh
        from canvasauthenticator import CanvasAuthenticator

        canvas_creds = z2jh.get_config('custom.canvas_creds', {})

        # Turn on canvas auth if explicitly asked to
        if z2jh.get_config('auth.type') == 'canvas':
          c.JupyterHub.authenticator_class = CanvasAuthenticator
          c.CanvasAuthenticator.canvas_url = 'https://bcourses.berkeley.edu/'
          c.CanvasAuthenticator.client_id = canvas_creds['client_id']
          c.CanvasAuthenticator.client_secret = canvas_creds['client_secret']
          c.CanvasAuthenticator.oauth_callback_url = canvas_creds['oauth_callback_url']
          c.CanvasAuthenticator.login_service = 'BCourses'
          c.CanvasAuthenticator.scope = ['url:GET|/api/v1/users/:user_id/profile']
          c.CanvasAuthenticator.username_key = 'primary_email'

      01-custom-attr-spawner: |
        import os
        from kubespawner import KubeSpawner
        from tornado import gen
        import z2jh

        hosted_domain = 'berkeley.edu'
        course_profile_tmpl = '/srv/jupyterhub/profiles.d/{}-{}.txt'

        def memparse(val):
          '''Parse memory for relative comparisons.'''
          if type(val) != str or len(val) == 0: return val
          mem = int(val.upper()[0:-1])
          unit = val[-1]
          n = {'B':0, 'K':1, 'M':2, 'G':3}[unit]
          return mem * 1024**n

        def mem_cmp(a, b):
          '''Compare memory values.'''
          x = memparse(a) ; y = memparse(b)
          return (x > y) - (x < y)

        def course_profile_filename(course, constituent):
          return course_profile_tmpl.format(course, constituent)

        def course_members(course, constituent, hd=None):
          '''Extracts usernames from files containing email addresses.'''
          members = []
          filename = course_profile_filename(course, constituent)
          if not os.path.exists(filename): return members
          with open(filename) as f:
            line = f.readline()
            while line != '':
              email = line.strip()
              if hd and email.endswith('@' + hd):
                members.append(email.split('@')[0])
              elif not hd:
                members.append(email)
              line = f.readline()
          return members

        class CustomAttrSpawner(KubeSpawner):

          @gen.coroutine
          def start(self):
            # custom.memory
            custom_memory = z2jh.get_config('custom.memory', {})
            for attr, users in custom_memory.items():
              if self.user.name in users:
                self.mem_limit = attr
                self.mem_guarantee = attr
                break

            # custom.profiles
            custom_profiles = z2jh.get_config('custom.profiles', {})
            is_student = False ; is_instructor = False
            for course, profile_data in custom_profiles.items():
              students    = course_members(course, 'students',    hosted_domain)
              instructors = course_members(course, 'instructors', hosted_domain)
              is_student    |= (self.user.name in students)
              is_instructor |= (self.user.name in instructors)
              if is_student or is_instructor:
                self.log.warning(f'using profile {course}')
                # set new mem thresholds if specified are bigger than current
                if 'mem_limit' in profile_data and \
                mem_cmp(profile_data['mem_limit'], self.mem_limit) == 1:
                  self.mem_limit = profile_data['mem_limit']
                if 'mem_guarantee' in profile_data and \
                mem_cmp(profile_data['mem_guarantee'], self.mem_guarantee) == 1:
                  self.mem_guarantee = profile_data['mem_guarantee']

            # if user is a student in any course, they never get to be an admin
            #if is_instructor and not is_student:
            #   self.user.admin = False

            # custom.admin
            custom_admin = z2jh.get_config('custom.admin', {})
            if custom_admin and self.user.admin:
              self.init_containers += custom_admin.get('initContainers', [])
              self.volume_mounts += custom_admin.get('extraVolumeMounts', [])

            return (yield super().start())

        c.JupyterHub.spawner_class = CustomAttrSpawner

        c.JupyterHub.extra_log_file = '/srv/jupyterhub/jupyterhub.log'

      02-lab-availability: |
        c.Spawner.cmd = ['jupyter-labhub']

      03-working-dir: |
        # Make sure working directory is ${HOME}
        # hubploy has a bug where it unconditionally puts workingdir to be /srv/repo
        c.KubeSpawner.working_dir = '/home/jovyan'
      05-prometheus: |
        # Allow unauthenticated prometheus requests
        # Otherwise our prometheus server can't get to these
        c.JupyterHub.authenticate_prometheus = False
